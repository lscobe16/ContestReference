\section{Datenstrukturen}

\begin{algorithm}{Iterative Segment Tree}
	\sourcecode{datastructures/iterSegT.cpp}	
\end{algorithm}

\begin{algorithm}{Mighty Segment Tree}
	\label{segT}
	Range updates, Range queries, implicit, ggf. persistent \\
	\method{lower\_bound}{}{\log(n)}
	Left to right:\\
	\tab smallest kex in [l, rex] such that p(agg([l, kex))), sth <0 if impossible\\
	\tab p should be increasing, i.e.  p(a1) <= p(agg(a1, a2))\\
	Right to left:\\
	\tab largest k in [l, rex] such that p(agg([k, rex))), or sth <0 if impossible\\
	\tab p should be decreasing, i.e.  p(agg(a1, a2)) <= p(a2)\\
	\textbf{Memory bei Persistent}: updates $\cdot$ 2 $\cdot$ log2(sz) $\cdot$ sizeof(segT::node)\\
	\tab Manchmal $\cdot$2 aufm Judge (diesmal: ja/nein)
	\sourcecode{datastructures/segT.cpp}
\end{algorithm}

\begin{algorithm}{Fenwick Tree}
	\begin{methods}
		\method{add}{addiert ein Delta zu einem Element}{\log(n)}
		\method{prefix\_sum}{Summe von [0, i)}{\log(n)}
	\end{methods}
	Grün: Werte strahlen exponentiell (\code{pot}) nach rechts aus.
	\sourcecode{datastructures/fenwickTree.cpp}
	
	\begin{methods}
		\method{init}{baut den Baum auf}{n\*\log(n)}
		\method{prefix\_sum}{summe von [0, i]}{\log(n)}
		\method{update}{addiert ein Delta zu allen Elementen [l, r)}{\log(n)}
	\end{methods}
	\sourcecode{datastructures/fenwickTree2.cpp}
\end{algorithm}

\begin{algorithm}{Treap}
	Addons: \green{lazy updates}, \yellow{key}, \blue{reverse (wenn kommutativ und kein key)}
	\sourcecode{datastructures/treap3.cpp}
\end{algorithm}

\begin{algorithm}{Range Minimum Query / Sparse Table}
	\label{sparse}
	\begin{methods}
		\method{init}{baut Struktur auf}{n\*\log(n)}
		\method{queryIdempotent}{Index des Minimums in [l, rex)}{1}
	\end{methods}
	\begin{itemize}
		\item \code{better}-Funktion muss idempotent sein!
	\end{itemize}
	\sourcecode{datastructures/sparseTable.cpp}
\end{algorithm}

% obsolete? (without range, pbds Trees can do that; persistent segTree can always do the rest)
\optional{
	\begin{algorithm}{Wavelet Tree}
		\begin{methods}
			\method{Constructor}{baut den Baum auf}{n\*\log(n)}
			\method{kth}{sort $[l, r)[k]$}{\log(n)}
			\method{countSmaller}{Anzahl elemente in $[l, r)$ kleiner als $k$}{\log(n)}
		\end{methods}
		\sourcecode{datastructures/waveletTree.cpp}
	\end{algorithm}
}

\columnbreak
\begin{algorithm}{Union-Find}
	\begin{methods}
		\method{init}{legt $n$ einzelne Mengen an}{n}
		\method[amort. $\O(\alpha(n))$]{find}{findet den Repräsentanten}{}
		\method[amort. $\O(\alpha(n))$]{unite}{vereint 2 Mengen}{}
		\method[amort. $\O(1)$]{\green{rollback}}{setzt Zustand zurück auf den mit time()=$t$}{}
	\end{methods}

	\green{Mit rollback: union + find nur noch in O(log(n)).}
	\sourcecode{datastructures/unionFind.cpp}
\end{algorithm}

\optional{
\begin{algorithm}{Lichao}
	\sourcecode{datastructures/lichao.cpp}
\end{algorithm}
}

\begin{algorithm}{Lower/Upper Envelope (Convex Hull Optimization)}
	Hier nur für lower envelopes.
	Um aus einem lower envelope einen upper envelope zu machen (oder umgekehrt), einfach beim Einfügen der Geraden $m$ und $b$ negieren.\\
	\begin{methods}
		\method[amort. $\O(1)$ bzw. amort. $\O(\log(n))$]{add}{$M := M \cup \{x \mapsto mx+b\}$}{}
		\method[amort. $\O(1)$ bzw. $\O(\log(n))$]{query}{$\min \{f(x) \mid f \in M\}$}{}
	\end{methods}
	\sourcecode{datastructures/monotonicConvexHull.cpp}
	\sourcecode{datastructures/dynamicConvexHull.cpp}
\end{algorithm}

\begin{algorithm}{Persistent}
	\begin{methods}
		\method{get}{berechnet Wert zu Zeitpunkt $t$}{\log(t)}
		\method{set}{ändert Wert zu Zeitpunkt $t$}{\log(t)}
		\method{reset}{setzt die Datenstruktur auf Zeitpunkt $t$}{1}
	\end{methods}
	\sourcecode{datastructures/persistent.cpp}
	\sourcecode{datastructures/persistentArray.cpp}
\end{algorithm}

\begin{algorithm}{STL-Bitset}
	\sourcecode{datastructures/bitset.cpp}
\end{algorithm}

\begin{algorithm}{Policy Based Data Structures (g++)}
    \textbf{Wichtig:} Verwende \code{p.swap(p2)} anstatt \code{swap(p, p2)}!
	\sourcecode{datastructures/stlPriorityQueue.cpp}
	\sourcecode{datastructures/stlTree.cpp}
	\sourcecode{datastructures/stlHash.cpp}
	\sourcecode{datastructures/stlRope.cpp}
\end{algorithm}



\begin{algorithm}[optional]{Range Minimum Query}
	\begin{methods}
		\method{init}{baut Struktur auf}{n\*\log(n)}
		\method{query}{Index des Minimums in [l, r)}{1}
	\end{methods}
	\sourcecode{datastructures/RMQ.cpp}
\end{algorithm}

\begin{algorithm}[optional]{Erste unbenutzte natürliche Zahl}
	\begin{methods}
		\method{get\_first\_unused}{findet kleinste unbenutzte Zahl}{\log(n)}
	\end{methods}
	\sourcecode{datastructures/firstUnused.cpp}
\end{algorithm}
