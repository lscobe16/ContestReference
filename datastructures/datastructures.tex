\section{Datenstrukturen}

\begin{algorithm}{Iterative Segment Tree}
	\sourcecode{datastructures/iterSegT.cpp}
	
	\subsubsection{Mighty Segment Tree}
	Range updates, Range queries, implicit, ggf. persistent \\
	\method{lower\_bound}{}{\log(n)}
	Left to right:\\
	\tab smallest kex in [l, rex] such that p(agg([l, kex))), sth <0 if impossible\\
	\tab p should be increasing, i.e.  p(a1) <= p(agg(a1, a2))\\
	Right to left:\\
	\tab largest k in [l, rex] such that p(agg([k, rex))), or sth <0 if impossible\\
	\tab p should be decreasing, i.e.  p(agg(a1, a2)) <= p(a2)
	\sourcecode{datastructures/segT.cpp}
\end{algorithm}

\begin{algorithm}{Fenwick Tree}
	\begin{methods}
		\method{init}{baut den Baum auf}{n\*\log(n)}
		\method{prefix\_sum}{summe von [0, i]}{\log(n)}
		\method{update}{addiert ein Delta zu einem Element}{\log(n)}
	\end{methods}
	\sourcecode{datastructures/fenwickTree.cpp}
	
	\begin{methods}
		\method{init}{baut den Baum auf}{n\*\log(n)}
		\method{prefix\_sum}{summe von [0, i]}{\log(n)}
		\method{update}{addiert ein Delta zu allen Elementen [l, r)}{\log(n)}
	\end{methods}
	\sourcecode{datastructures/fenwickTree2.cpp}
\end{algorithm}
% \clearpage

\begin{algorithm}{STL-Rope (Implicit Cartesian Tree)}
	\sourcecode{datastructures/stlRope.cpp}
\end{algorithm}

\begin{algorithm}{(Implicit) Treap (Cartesian Tree)}
	\begin{methods}
		\method{insert}{fügt wert $\mathit{val}$ an stelle $i$ ein (verschiebt alle Positionen >= $i$)}{\log(n)}
		\method{remove}{löscht werte $[i,i+\mathit{count})$}{\log(n)}
	\end{methods}
	\sourcecode{datastructures/treap2.cpp}
\end{algorithm}

\begin{algorithm}{Range Minimum Query}
	\begin{methods}
		\method{init}{baut Struktur auf}{n\*\log(n)}
		\method{queryIdempotent}{Index des Minimums in [l, r)}{1}
	\end{methods}
	\begin{itemize}
		\item \code{better}-Funktion muss idempotent sein!
	\end{itemize}
	\sourcecode{datastructures/sparseTable.cpp}
\end{algorithm}

\begin{algorithm}{Wavelet Tree}
	\begin{methods}
		\method{Constructor}{baut den Baum auf}{n\*\log(n)}
		\method{kth}{sort $[l, r)[k]$}{\log(n)}
		\method{countSmaller}{Anzahl elemente in $[l, r)$ kleiner als $k$}{\log(n)}
	\end{methods}
	\sourcecode{datastructures/waveletTree.cpp}
\end{algorithm}

\begin{algorithm}{STL-Bitset}
	\sourcecode{datastructures/bitset.cpp}
\end{algorithm}

\begin{algorithm}{Link-Cut-Tree}
	\begin{methods}
		\method{Constructor}{baut Wald auf}{n}
		\method{connected}{prüft ob zwei Knoten im selben Baum liegen}{\log(n)}
		\method{link}{fügt $\{x,y\}$ Kante ein}{\log(n)}
		\method{cut}{entfernt $\{x,y\}$ Kante}{\log(n)}
		\method{lca}{berechnet LCA von $x$ und $y$}{\log(n)}
		\method{query}{berechnet \code{query} auf den Knoten des $xy$-Pfades}{\log(n)}
		\method{modify}{erhöht jeden wert auf dem $xy$-Pfad}{\log(n)}
	\end{methods}
	\sourcecode{datastructures/LCT.cpp}
\end{algorithm}
\clearpage

\begin{algorithm}{Union-Find}
	\begin{methods}
		\method{init}{legt $n$ einzelne Unions an}{n}
		\method{findSet}{findet den Repräsentanten}{\log(n)}
		\method{unionSets}{vereint 2 Mengen}{\log(n)}
		\method{m\*findSet + n\*unionSets}{Folge von Befehlen}{n+m\*\alpha(n)}
	\end{methods}
	\sourcecode{datastructures/unionFind.cpp}
\end{algorithm}

\begin{algorithm}{Lower/Upper Envelope (Convex Hull Optimization)}
	Um aus einem lower envelope einen upper envelope zu machen (oder umgekehrt), einfach beim Einfügen der Geraden $m$ und $b$ negieren.
	\sourcecode{datastructures/monotonicConvexHull.cpp}
	\columnbreak
	\sourcecode{datastructures/dynamicConvexHull.cpp}
\end{algorithm}

\begin{algorithm}{Persistent}
	\begin{methods}
		\method{get}{berechnet Wert zu Zeitpunkt $t$}{\log(t)}
		\method{set}{ändert Wert zu Zeitpunkt $t$}{\log(t)}
		\method{reset}{setzt die Datenstruktur auf Zeitpunkt $t$}{1}
	\end{methods}
	\sourcecode{datastructures/persistent.cpp}
	\sourcecode{datastructures/persistentArray.cpp}
\end{algorithm}

\begin{algorithm}{STL-Tree}
	\sourcecode{datastructures/stlTree.cpp}
\end{algorithm}

\begin{algorithm}{STL Priority Queue}
	Nicht notwendig, wenn Smaller-Larger-Optimization greift.
	\sourcecode{datastructures/stlPQ.cpp}
\end{algorithm}

\begin{algorithm}{STL HashMap}
	3 bis 4 mal langsamer als \code{std::vector} aber 8 bis 9 mal schneller als \code{std::map}
	\sourcecode{datastructures/stlHashMap.cpp}
\end{algorithm}



\begin{algorithm}[optional]{Range Minimum Query}
	\begin{methods}
		\method{init}{baut Struktur auf}{n\*\log(n)}
		\method{query}{Index des Minimums in [l, r)}{1}
	\end{methods}
	\sourcecode{datastructures/RMQ.cpp}
\end{algorithm}

\begin{algorithm}[optional]{Erste unbenutzte natürliche Zahl}
	\begin{methods}
		\method{get\_first\_unused}{findet kleinste unbenutzte Zahl}{\log(n)}
	\end{methods}
	\sourcecode{datastructures/firstUnused.cpp}
\end{algorithm}

